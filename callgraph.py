import json
import os
from typing import List, Set
from func_info import FuncInfo
from utils.array import first_index_of
from collections import deque


'''
read callgraph json and parse it
'''
class Callgraph:
    # filepath is the json file, not the project path
    def __init__(self, filepath: str, project_base_dir=''):
        with open(filepath, 'r') as f:
            content = json.load(f)
        self.project_base_dir = project_base_dir
        self.entries = self.resolve_files(content['entries'])
        self.files = self.resolve_files(content['files'])
        self.functions = [
            self.get_func_info(def_site) for _, def_site in content['functions'].items()
        ]
        self.fun2fun = [
            (edge[0], edge[1]) for edge in content['fun2fun']
        ]

    def resolve_files(self, files: List[str]) -> List[str]:
        if self.project_base_dir == '':
            return files
        return [
            os.path.join(self.project_base_dir, file) for file in files
        ]

    def get_func_info(self, def_site: str) -> FuncInfo:
        file_idx = int(str.split(def_site, ':')[0])
        return FuncInfo(self.files[file_idx], def_site)

    def get_reachable_func_idxs(self) -> Set[int]:
        reachable_func_idx_set = set[int]()
        # entry file will be executed
        # reachable tree roots from entry function
        for entry in self.entries:
            file_idx = self.files.index(entry)
            # bfs for each entry
            worklist = deque()

            def cond_entry_func(info: FuncInfo) -> bool:
                return info.def_site == [file_idx, -1, -1, -1, -1]

            entry_func_idx = first_index_of(self.functions, cond_entry_func)
            assert entry_func_idx is not None
            reachable_func_idx_set.add(entry_func_idx)
            worklist.append(entry_func_idx)
            while len(worklist) > 0:
                func_idx = worklist.popleft()
                for edge in self.fun2fun:
                    # avoid duplicate
                    if edge[0] == func_idx and edge[1] not in reachable_func_idx_set:
                        reachable_func_idx_set.add(edge[1])
                        worklist.append(edge[1])
        return reachable_func_idx_set

